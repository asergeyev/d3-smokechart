{"version":3,"file":"d3-smokechart.min.js","sources":["../dist/index.js"],"sourcesContent":["import { scaleLinear } from \"d3-scale\";\nimport { line } from \"d3-shape\";\nconst quantile = (probes, q) => {\n    if (q < 0 || q > 1 || isNaN(q))\n        throw new Error(`Unable to calculate ${q} quantile`);\n    var alq = (probes.length - 1) * q;\n    var idx = Math.floor(alq);\n    var diff = alq - idx;\n    return diff < 0.001 ? probes[idx] : Math.floor(probes[idx] * (1 - diff) + probes[idx + 1] * diff + 0.5);\n};\nconst smokeAreaConfig = [\n    [],\n    [[0, 1]],\n    [[0, 1], [.25, .75]],\n    [[0, 1], [.15, .85], [.3, .7]],\n    [[0, 1], [.1, .9], [.2, .8], [.3, .7]],\n    [[0, 1], [.1, .9], [.2, .8], [.3, .7], [.4, .6]]\n];\nexport const calculateSmokeBands = (v, bands) => {\n    const bandKind = smokeAreaConfig[bands];\n    return bandKind.map(([from, to]) => [quantile(v, from), quantile(v, to)]);\n};\nconst flameAreaConfig = [\n    [],\n    [.5],\n    [.5, .75],\n    [.5, .7, .9],\n    [.4, .55, .7, .85],\n    [.5, .6, .7, .8, .9]\n];\nexport const Smokechart = (smokeData, opts) => {\n    const props = {\n        scaleX: scaleLinear(),\n        scaleY: scaleLinear(),\n    };\n    let data = [];\n    let errs = [];\n    let classSuffix = Math.floor(Math.random() * 100000);\n    const smoke = (smokeData, opts) => {\n        if (smokeData && !Array.isArray(smokeData)) {\n            opts = smokeData;\n            smokeData = undefined;\n        }\n        if (opts)\n            Object.assign(props, opts);\n        if (smokeData)\n            smoke.data(smokeData);\n        classSuffix = Math.floor(Math.random() * 100000);\n        return smoke;\n    };\n    smoke.data = (smokeData) => {\n        if (smokeData) {\n            data = smokeData.map(arr => [...arr.filter(n => !isNaN(n))].sort((a, b) => a - b));\n            errs = smokeData.map(arr => {\n                return {\n                    errors: [...arr.filter(n => isNaN(n))].length,\n                    count: arr.length,\n                };\n            });\n            return smoke;\n        }\n        return data;\n    };\n    smoke.adjustScaleRange = () => {\n        if (props.scaleX)\n            props.scaleX.domain([0, data.length]);\n        if (!props.scaleY)\n            return;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        data.forEach(arr => {\n            if (arr.length) {\n                if (arr[0] < minY)\n                    minY = arr[0];\n                if (arr[arr.length - 1] > maxY)\n                    maxY = arr[arr.length - 1];\n            }\n        });\n        props.scaleY.domain([minY, maxY]);\n        return smoke;\n    };\n    smoke.scaleX = (newScale) => {\n        if (newScale) {\n            props.scaleX = newScale;\n            return smoke;\n        }\n        return props.scaleX;\n    };\n    smoke.scaleY = (newScale) => {\n        if (newScale) {\n            props.scaleY = newScale;\n            return smoke;\n        }\n        return props.scaleY;\n    };\n    smoke.line = (q = 0.5) => {\n        const l = line()\n            .x(d => props.scaleX(d[0]))\n            .y(d => props.scaleY(d[1]));\n        const quantileData = data.reduce((reslt, values, idx) => {\n            const p = quantile(values, q);\n            return [...reslt, [idx - 0.5, p], [idx + 0.5, p]];\n        }, []);\n        return [l(quantileData)];\n    };\n    smoke.smokeBands = (bCount = 2) => {\n        const l = line()\n            .x(d => props.scaleX(d[0]))\n            .y(d => props.scaleY(d[1]));\n        const bands = data.reduce((reslt, values, idx) => {\n            const bandData = calculateSmokeBands(values, bCount);\n            const x = idx - 0.5;\n            const bandLines = bandData.map(([y0, y1]) => l([\n                [x, y0],\n                [x, y1],\n                [x + 1, y1],\n                [x + 1, y0],\n            ]) || \"\");\n            return [...reslt, bandLines];\n        }, []);\n        return bands[0].map((_, columnIdx) => bands.map(row => row[columnIdx]).join(\"\"));\n    };\n    smoke.countErrors = () => {\n        return errs.map(v => v.errors);\n    };\n    smoke.chart = (selection, args) => {\n        if (args === null || args === void 0 ? void 0 : args.bands) {\n            selection\n                .selectAll(\"path.smokechart-band\" + classSuffix)\n                .data(smoke.smokeBands(args === null || args === void 0 ? void 0 : args.bands))\n                .enter()\n                .append(\"path\")\n                .classed(\"smokechart-band\", true)\n                .attr(\"fill\", \"rgba(0,0,0,0.18)\")\n                .attr(\"d\", (d) => d);\n        }\n        selection\n            .selectAll(\"path.smokechart-line\" + classSuffix)\n            .data(smoke.line(0.5))\n            .enter()\n            .append(\"path\")\n            .classed(\"smokechart-line\", true)\n            .attr(\"stroke\", \"#ff0000\")\n            .attr(\"stroke-width\", 1)\n            .attr(\"fill\", \"transparent\")\n            .attr(\"d\", (d) => d);\n        const eRadius = (args === null || args === void 0 ? void 0 : args.errorRadius) || 0;\n        if (eRadius > 0) {\n            const paths = errs.map(({ errors, count }, pos) => {\n                if (errors > 0 && count > 0) {\n                    const xPos = props.scaleX(pos);\n                    const alpha = (Math.PI * 2 * errors) / count;\n                    const endX = eRadius * Math.sin(alpha) + xPos;\n                    const endY = eRadius * Math.cos(alpha + Math.PI) + 1 + eRadius;\n                    return `M ${xPos},${eRadius + 1} v-${eRadius} A ${eRadius},${eRadius} 0,0,1 ${endX},${endY} Z`;\n                }\n            });\n            selection\n                .selectAll(\"path.smokechart-errs\")\n                .data([paths.join(\" \")])\n                .enter()\n                .append(\"path\")\n                .attr(\"fill\", \"#f30\")\n                .attr(\"d\", (d) => d);\n        }\n    };\n    return smoke(smokeData, opts);\n};\n"],"names":["quantile","probes","q","isNaN","Error","alq","length","idx","Math","floor","diff","smokeAreaConfig","calculateSmokeBands","v","bands","map","from","to","smokeData","opts","props","scaleX","scaleLinear","scaleY","data","errs","classSuffix","random","smoke","Array","isArray","undefined","Object","assign","arr","filter","n","sort","a","b","errors","count","adjustScaleRange","domain","minY","Infinity","maxY","forEach","newScale","line","x","d","y","l","reduce","reslt","values","p","smokeBands","bCount","bandData","y0","y1","_","columnIdx","row","join","countErrors","chart","selection","args","selectAll","enter","append","classed","attr","eRadius","errorRadius","paths","pos","xPos","alpha","PI","endX","sin","endY","cos"],"mappings":"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"}