{"version":3,"file":"d3-smokechart.min.js","sources":["../dist/index.js"],"sourcesContent":["import { line } from \"d3-shape\";\nconst quantile = (probes, q) => {\n    if (q < 0 || q > 1 || isNaN(q))\n        throw new Error(`Unable to calculate ${q} quantile`);\n    var alq = (probes.length - 1) * q;\n    var idx = Math.floor(alq);\n    var diff = alq - idx;\n    return diff < 0.001 ? probes[idx] : Math.floor(probes[idx] * (1 - diff) + probes[idx + 1] * diff + 0.5);\n};\nconst smokeAreaConfig = [\n    [],\n    [[0, 1]],\n    [[0, 1], [.25, .75]],\n    [[0, 1], [.15, .85], [.3, .7]],\n    [[0, 1], [.1, .9], [.2, .8], [.3, .7]],\n    [[0, 1], [.1, .9], [.2, .8], [.3, .7], [.4, .6]]\n];\nexport const calculateSmokeBands = (v, bands) => {\n    const bandKind = smokeAreaConfig[bands];\n    return bandKind.map(([from, to]) => [quantile(v, from), quantile(v, to)]);\n};\nconst flameAreaConfig = [\n    [],\n    [.5],\n    [.5, .75],\n    [.5, .7, .9],\n    [.4, .55, .7, .85],\n    [.5, .6, .7, .8, .9]\n];\nexport const Smokechart = (smokeData, opts) => {\n    const props = {};\n    let data = [];\n    let classSuffix = Math.floor(Math.random() * 100000);\n    const smoke = (smokeData, opts) => {\n        if (smokeData && !Array.isArray(smokeData)) {\n            opts = smokeData;\n            smokeData = undefined;\n        }\n        if (opts)\n            Object.assign(props, opts);\n        if (smokeData)\n            smoke.data(smokeData);\n        classSuffix = Math.floor(Math.random() * 100000);\n        return smoke;\n    };\n    smoke.data = (smokeData) => {\n        if (smokeData) {\n            data = smokeData.map(arr => [...arr.filter(n => !isNaN(n))].sort((a, b) => a - b));\n            return smoke;\n        }\n        return data;\n    };\n    smoke.adjustScaleRange = () => {\n        if (props.scaleX)\n            props.scaleX.domain([0, data.length]);\n        if (!props.scaleY)\n            return;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        data.forEach(arr => {\n            if (arr.length) {\n                if (arr[0] < minY)\n                    minY = arr[0];\n                if (arr[arr.length - 1] > maxY)\n                    maxY = arr[arr.length - 1];\n            }\n        });\n        props.scaleY.domain([minY, maxY]);\n        return smoke;\n    };\n    smoke.scaleX = (newScale) => {\n        if (newScale) {\n            props.scaleX = newScale;\n            return smoke;\n        }\n        return props.scaleX;\n    };\n    smoke.scaleY = (newScale) => {\n        if (newScale) {\n            props.scaleY = newScale;\n            return smoke;\n        }\n        return props.scaleY;\n    };\n    smoke.line = (q = 0.5) => {\n        const l = line()\n            .x(d => (props.scaleX ? props.scaleX(d[0]) : d[0]))\n            .y(d => (props.scaleY ? props.scaleY(d[1]) : d[1]));\n        const quantileData = data.reduce((reslt, values, idx) => {\n            const p = quantile(values, q);\n            return [...reslt, [idx - 0.5, p], [idx + 0.5, p]];\n        }, []);\n        return [l(quantileData)];\n    };\n    smoke.smokeBands = (bCount = 2) => {\n        const l = line()\n            .x(d => (props.scaleX ? props.scaleX(d[0]) : d[0]))\n            .y(d => (props.scaleY ? props.scaleY(d[1]) : d[1]));\n        const bands = data.reduce((reslt, values, idx) => {\n            const bandData = calculateSmokeBands(values, bCount);\n            const x = idx - 0.5;\n            const bandLines = bandData.map(([y0, y1]) => l([\n                [x, y0],\n                [x, y1],\n                [x + 1, y1],\n                [x + 1, y0],\n            ]) || \"\");\n            return [...reslt, bandLines];\n        }, []);\n        return bands[0].map((_, columnIdx) => bands.map(row => row[columnIdx]).join(\"\"));\n    };\n    smoke.countErrors = (probeCount = -1) => {\n        const values = data.map(list => list.length);\n        const desired = probeCount >= 0 ? probeCount : Math.max(...values);\n        const underCount = values.map(ln => (desired > ln ? desired - ln : 0));\n        return underCount.reduce((ret, under, idx) => {\n            if (under > 0) {\n                const elems = [];\n                const x = props.scaleX ? props.scaleX(idx) : idx;\n                for (let errPos = 0; errPos < under; errPos++)\n                    elems.push({ x, errPos });\n                return [...ret, ...elems];\n            }\n            return ret;\n        }, []);\n    };\n    smoke.chart = (selection, args) => {\n        if (args === null || args === void 0 ? void 0 : args.bands) {\n            selection\n                .selectAll(\"path.smokechart-band\" + classSuffix)\n                .data(smoke.smokeBands(args === null || args === void 0 ? void 0 : args.bands))\n                .enter()\n                .append(\"path\")\n                .classed(\"smokechart-band\", true)\n                .attr(\"fill\", \"rgba(0,0,0,0.18)\")\n                .attr(\"d\", (d) => d);\n        }\n        selection\n            .selectAll(\"path.smokechart-line\" + classSuffix)\n            .data(smoke.line(0.5))\n            .enter()\n            .append(\"path\")\n            .classed(\"smokechart-line\", true)\n            .attr(\"stroke\", \"#ff0000\")\n            .attr(\"stroke-width\", 1.1)\n            .attr(\"fill\", \"transparent\")\n            .attr(\"d\", (d) => d);\n        if (args === null || args === void 0 ? void 0 : args.errors) {\n            const errors = smoke.countErrors() || [];\n            if (errors.length) {\n                selection\n                    .selectAll(\"circle.smokechart-baseline\" + classSuffix)\n                    .data(errors)\n                    .enter()\n                    .append(\"circle\")\n                    .attr(\"cx\", (d) => d.x)\n                    .attr(\"cy\", (d) => 3 + d.errPos * 4.5)\n                    .attr(\"r\", 2)\n                    .attr(\"fill\", \"#f30\");\n            }\n        }\n    };\n    return smoke(smokeData, opts);\n};\n"],"names":["quantile","probes","q","isNaN","Error","alq","length","idx","Math","floor","diff","smokeAreaConfig","calculateSmokeBands","v","bands","map","from","to","smokeData","opts","props","data","classSuffix","random","smoke","Array","isArray","undefined","Object","assign","arr","filter","n","sort","a","b","adjustScaleRange","scaleX","domain","scaleY","minY","Infinity","maxY","forEach","newScale","line","x","d","y","l","reduce","reslt","values","p","smokeBands","bCount","bandData","y0","y1","_","columnIdx","row","join","countErrors","probeCount","list","desired","max","ln","ret","under","elems","errPos","push","chart","selection","args","selectAll","enter","append","classed","attr","errors"],"mappings":"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"}